{"ast":null,"code":"import _asyncToGenerator from \"H:/dev/my_workflow/my-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _regeneratorRuntime from \"H:/dev/my_workflow/my-app/node_modules/@babel/runtime/regenerator\";\nimport { assign } from 'xstate';\nimport store from 'store2';\n\nvar toSessionKey = function toSessionKey(workflow_type, instance) {\n  return \"session:\".concat(workflow_type, \"-\").concat(instance);\n};\n\nvar toCacheKey = function toCacheKey(workflow_type, instance) {\n  return \"state:\".concat(workflow_type, \"-\").concat(instance);\n};\n\nvar actions = {\n  saveSessionToken: function saveSessionToken(_ref, _ref2) {\n    var workflow_type = _ref.workflow_type,\n        instance = _ref.instance;\n    var payload = _ref2.payload;\n    store.set(toSessionKey(workflow_type, instance), payload);\n  },\n  assignWorkflowState: assign({\n    workflow_state: function workflow_state(_, _ref3) {\n      var payload = _ref3.payload;\n\n      try {\n        return payload;\n      } catch (error) {\n        return undefined;\n      }\n    }\n  }),\n  setWorkflowStateCache: function () {\n    var _setWorkflowStateCache = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref4, _ref5) {\n      var workflow_type, instance, payload;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              workflow_type = _ref4.workflow_type, instance = _ref4.instance;\n              payload = _ref5.payload;\n              return _context.abrupt(\"return\", // return store.set(`cache:${workflow_type}:state`, payload);\n              store.set(toCacheKey(workflow_type, instance), payload));\n\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function setWorkflowStateCache(_x, _x2) {\n      return _setWorkflowStateCache.apply(this, arguments);\n    }\n\n    return setWorkflowStateCache;\n  }(),\n  applyCachedState: assign({\n    workflow_state: function workflow_state(_, _ref6) {\n      var cached_state = _ref6.data;\n\n      try {\n        return cached_state;\n      } catch (error) {\n        return undefined;\n      }\n    }\n  })\n};\nexport default actions;","map":{"version":3,"sources":["H:/dev/my_workflow/my-app/src/client/applications/search-vacancies/machine/options/actions/assigners.ts"],"names":["assign","store","toSessionKey","workflow_type","instance","toCacheKey","actions","saveSessionToken","payload","set","assignWorkflowState","workflow_state","_","error","undefined","setWorkflowStateCache","applyCachedState","cached_state","data"],"mappings":";;AAAA,SAA4BA,MAA5B,QAA0C,QAA1C;AAEA,OAAOC,KAAP,MAAkB,QAAlB;;AAEA,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAACC,aAAD,EAAwBC,QAAxB;AAAA,2BACRD,aADQ,cACSC,QADT;AAAA,CAArB;;AAGA,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAACF,aAAD,EAAwBC,QAAxB;AAAA,yBACRD,aADQ,cACSC,QADT;AAAA,CAAnB;;AAGA,IAAME,OAAoD,GAAG;AAC3DC,EAAAA,gBAAgB,EAAE,uCAA8C;AAAA,QAA3CJ,aAA2C,QAA3CA,aAA2C;AAAA,QAA5BC,QAA4B,QAA5BA,QAA4B;AAAA,QAAdI,OAAc,SAAdA,OAAc;AAC9DP,IAAAA,KAAK,CAACQ,GAAN,CAAUP,YAAY,CAACC,aAAD,EAAgBC,QAAhB,CAAtB,EAAiDI,OAAjD;AACD,GAH0D;AAI3DE,EAAAA,mBAAmB,EAAEV,MAAM,CAAC;AAC1BW,IAAAA,cAAc,EAAE,wBAACC,CAAD,SAAoB;AAAA,UAAdJ,OAAc,SAAdA,OAAc;;AAClC,UAAI;AACF,eAAOA,OAAP;AACD,OAFD,CAEE,OAAOK,KAAP,EAAc;AACd,eAAOC,SAAP;AACD;AACF;AAPyB,GAAD,CAJgC;AAa3DC,EAAAA,qBAAqB;AAAA,0FAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAASZ,cAAAA,aAAT,SAASA,aAAT,EAAwBC,QAAxB,SAAwBA,QAAxB;AAAsCI,cAAAA,OAAtC,SAAsCA,OAAtC;AAAA,+CACrB;AACAP,cAAAA,KAAK,CAACQ,GAAN,CAAUJ,UAAU,CAACF,aAAD,EAAgBC,QAAhB,CAApB,EAA+CI,OAA/C,CAFqB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA,KAbsC;AAgB3DQ,EAAAA,gBAAgB,EAAEhB,MAAM,CAAC;AACvBW,IAAAA,cAAc,EAAE,wBAACC,CAAD,SAA+B;AAAA,UAAnBK,YAAmB,SAAzBC,IAAyB;;AAC7C,UAAI;AACF,eAAOD,YAAP;AACD,OAFD,CAEE,OAAOJ,KAAP,EAAc;AACd,eAAOC,SAAP;AACD;AACF;AAPsB,GAAD;AAhBmC,CAA7D;AA2BA,eAAeR,OAAf","sourcesContent":["import { ActionFunctionMap, assign } from 'xstate';\nimport { IContext, IMachineEvents } from '../../types';\nimport store from 'store2';\n\nconst toSessionKey = (workflow_type: string, instance: string | number) =>\n  `session:${workflow_type}-${instance}`;\n\nconst toCacheKey = (workflow_type: string, instance: string | number) =>\n  `state:${workflow_type}-${instance}`;\n\nconst actions: ActionFunctionMap<IContext, IMachineEvents> = {\n  saveSessionToken: ({ workflow_type, instance }, { payload }) => {\n    store.set(toSessionKey(workflow_type, instance), payload);\n  },\n  assignWorkflowState: assign({\n    workflow_state: (_, { payload }) => {\n      try {\n        return payload;\n      } catch (error) {\n        return undefined;\n      }\n    },\n  }),\n  setWorkflowStateCache: async ({ workflow_type, instance }, { payload }) =>\n    // return store.set(`cache:${workflow_type}:state`, payload);\n    store.set(toCacheKey(workflow_type, instance), payload),\n  applyCachedState: assign({\n    workflow_state: (_, { data: cached_state }) => {\n      try {\n        return cached_state;\n      } catch (error) {\n        return undefined;\n      }\n    },\n  }),\n};\n\nexport default actions;\n"]},"metadata":{},"sourceType":"module"}