{"ast":null,"code":"import { assign } from 'xstate';\nimport store from 'store2';\n\nconst toSessionKey = (workflow_type, instance) => `session:${workflow_type}-${instance}`;\n\nconst toCacheKey = (workflow_type, instance) => `state:${workflow_type}-${instance}`;\n\nconst actions = {\n  saveSessionToken: ({\n    workflow_type,\n    instance\n  }, {\n    payload\n  }) => {\n    store.set(toSessionKey(workflow_type, instance), payload);\n  },\n  assignWorkflowState: assign({\n    workflow_state: (_, {\n      payload\n    }) => {\n      try {\n        return payload;\n      } catch (error) {\n        return undefined;\n      }\n    }\n  }),\n  setWorkflowStateCache: async ({\n    workflow_type,\n    instance\n  }, {\n    payload\n  }) => // return store.set(`cache:${workflow_type}:state`, payload);\n  store.set(toCacheKey(workflow_type, instance), payload),\n  applyCachedState: assign({\n    workflow_state: (_, {\n      data: cached_state\n    }) => {\n      try {\n        return cached_state;\n      } catch (error) {\n        return undefined;\n      }\n    }\n  })\n};\nexport default actions;","map":{"version":3,"sources":["H:/dev/my_workflow/my-app/src/client/applications/search-vacancies/machine/options/actions/assigners.ts"],"names":["assign","store","toSessionKey","workflow_type","instance","toCacheKey","actions","saveSessionToken","payload","set","assignWorkflowState","workflow_state","_","error","undefined","setWorkflowStateCache","applyCachedState","data","cached_state"],"mappings":"AAAA,SAA4BA,MAA5B,QAA0C,QAA1C;AAEA,OAAOC,KAAP,MAAkB,QAAlB;;AAEA,MAAMC,YAAY,GAAG,CAACC,aAAD,EAAwBC,QAAxB,KAClB,WAAUD,aAAc,IAAGC,QAAS,EADvC;;AAGA,MAAMC,UAAU,GAAG,CAACF,aAAD,EAAwBC,QAAxB,KAChB,SAAQD,aAAc,IAAGC,QAAS,EADrC;;AAGA,MAAME,OAAoD,GAAG;AAC3DC,EAAAA,gBAAgB,EAAE,CAAC;AAAEJ,IAAAA,aAAF;AAAiBC,IAAAA;AAAjB,GAAD,EAA8B;AAAEI,IAAAA;AAAF,GAA9B,KAA8C;AAC9DP,IAAAA,KAAK,CAACQ,GAAN,CAAUP,YAAY,CAACC,aAAD,EAAgBC,QAAhB,CAAtB,EAAiDI,OAAjD;AACD,GAH0D;AAI3DE,EAAAA,mBAAmB,EAAEV,MAAM,CAAC;AAC1BW,IAAAA,cAAc,EAAE,CAACC,CAAD,EAAI;AAAEJ,MAAAA;AAAF,KAAJ,KAAoB;AAClC,UAAI;AACF,eAAOA,OAAP;AACD,OAFD,CAEE,OAAOK,KAAP,EAAc;AACd,eAAOC,SAAP;AACD;AACF;AAPyB,GAAD,CAJgC;AAa3DC,EAAAA,qBAAqB,EAAE,OAAO;AAAEZ,IAAAA,aAAF;AAAiBC,IAAAA;AAAjB,GAAP,EAAoC;AAAEI,IAAAA;AAAF,GAApC,KACrB;AACAP,EAAAA,KAAK,CAACQ,GAAN,CAAUJ,UAAU,CAACF,aAAD,EAAgBC,QAAhB,CAApB,EAA+CI,OAA/C,CAfyD;AAgB3DQ,EAAAA,gBAAgB,EAAEhB,MAAM,CAAC;AACvBW,IAAAA,cAAc,EAAE,CAACC,CAAD,EAAI;AAAEK,MAAAA,IAAI,EAAEC;AAAR,KAAJ,KAA+B;AAC7C,UAAI;AACF,eAAOA,YAAP;AACD,OAFD,CAEE,OAAOL,KAAP,EAAc;AACd,eAAOC,SAAP;AACD;AACF;AAPsB,GAAD;AAhBmC,CAA7D;AA2BA,eAAeR,OAAf","sourcesContent":["import { ActionFunctionMap, assign } from 'xstate';\nimport { IContext, IMachineEvents } from '../../types';\nimport store from 'store2';\n\nconst toSessionKey = (workflow_type: string, instance: string | number) =>\n  `session:${workflow_type}-${instance}`;\n\nconst toCacheKey = (workflow_type: string, instance: string | number) =>\n  `state:${workflow_type}-${instance}`;\n\nconst actions: ActionFunctionMap<IContext, IMachineEvents> = {\n  saveSessionToken: ({ workflow_type, instance }, { payload }) => {\n    store.set(toSessionKey(workflow_type, instance), payload);\n  },\n  assignWorkflowState: assign({\n    workflow_state: (_, { payload }) => {\n      try {\n        return payload;\n      } catch (error) {\n        return undefined;\n      }\n    },\n  }),\n  setWorkflowStateCache: async ({ workflow_type, instance }, { payload }) =>\n    // return store.set(`cache:${workflow_type}:state`, payload);\n    store.set(toCacheKey(workflow_type, instance), payload),\n  applyCachedState: assign({\n    workflow_state: (_, { data: cached_state }) => {\n      try {\n        return cached_state;\n      } catch (error) {\n        return undefined;\n      }\n    },\n  }),\n};\n\nexport default actions;\n"]},"metadata":{},"sourceType":"module"}